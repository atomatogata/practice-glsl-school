export class WebGLUtility{static loadFile(e){return new Promise((r,t)=>{fetch(e).then(e=>e.text()).then(e=>{r(e)}).catch(e=>{t(e)})})}static loadImage(e){return new Promise(r=>{const t=new Image;t.addEventListener("load",()=>{r(t)},!1),t.src=e})}static createShader(e,r,t){const a=e.createShader(t);return e.shaderSource(a,r),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS)?a:(alert(e.getShaderInfoLog(a)),null)}static createProgram(e,r,t){const a=e.createProgram();return e.attachShader(a,r),e.attachShader(a,t),e.linkProgram(a),e.getProgramParameter(a,e.LINK_STATUS)?(e.useProgram(a),a):(alert(e.getProgramInfoLog(a)),null)}static createTransformFeedbackProgram(e,r,t,a){const n=e.createProgram();return e.attachShader(n,r),e.attachShader(n,t),e.transformFeedbackVaryings(n,a,e.SEPARATE_ATTRIBS),e.linkProgram(n),e.getProgramParameter(n,e.LINK_STATUS)?(e.useProgram(n),n):(alert(e.getProgramInfoLog(n)),null)}static createVbo(e,r){const t=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),t}static createIbo(e,r){const t=e.createBuffer();return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Int16Array(r),e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),t}static createIboInt(e,r,t){if(null==r||null==r.elementIndexUint)throw new Error("element index Uint not supported");const a=e.createBuffer();return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,a),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint32Array(t),e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),a}static createTextureFromFile(e,r){return new Promise(t=>{const a=new Image;a.addEventListener("load",()=>{const r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,a),e.generateMipmap(e.TEXTURE_2D),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null),t(r)},!1),a.src=r})}static createFramebuffer(e,r,t){const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a);const n=e.createRenderbuffer();e.bindRenderbuffer(e.RENDERBUFFER,n),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,r,t),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,n);const E=e.createTexture();return e.bindTexture(e.TEXTURE_2D,E),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r,t,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,E,0),e.bindTexture(e.TEXTURE_2D,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.bindFramebuffer(e.FRAMEBUFFER,null),{framebuffer:a,renderbuffer:n,texture:E}}static createFramebufferFloat(e,r,t,a){if(null==r||null==r.textureFloat&&null==r.textureHalfFloat)throw new Error("float texture not supported");const n=null!=r.textureFloat?e.FLOAT:r.textureHalfFloat.HALF_FLOAT_OES,E=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,E);const i=e.createTexture();return e.bindTexture(e.TEXTURE_2D,i),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,a,0,e.RGBA,n,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,i,0),e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),{framebuffer:E,texture:i}}static createFramebufferFloat2(e,r,t){const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a);const n=e.createTexture();return e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,r,t,0,e.RGBA,e.FLOAT,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0),e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),{framebuffer:a,texture:n}}static deleteFrameBuffer(e,r){null!=r&&(!0===r.hasOwnProperty("framebuffer")&&!0===e.isFramebuffer(r.framebuffer)&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(r.framebuffer),r.framebuffer=null),!0===r.hasOwnProperty("renderbuffer")&&!0===e.isRenderbuffer(r.renderbuffer)&&(e.bindRenderbuffer(e.RENDERBUFFER,null),e.deleteRenderbuffer(r.renderbuffer),r.renderbuffer=null),!0===r.hasOwnProperty("texture")&&!0===e.isTexture(r.texture)&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(r.texture),r.texture=null),r=null)}static getWebGLExtensions(e){return{elementIndexUint:e.getExtension("OES_element_index_uint"),textureFloat:e.getExtension("OES_texture_float"),textureHalfFloat:e.getExtension("OES_texture_half_float")}}}export class ShaderProgram{constructor(e,r){if(this.gl=e,this.vertexShaderSource=r.vertexShaderSource,this.fragmentShaderSource=r.fragmentShaderSource,this.attribute=r.attribute,this.stride=r.stride,this.uniform=r.uniform,this.type=r.type,this.transformFeedbackVaryings=r.transformFeedbackVaryings,!0!==Array.isArray(this.attribute)||!0!==Array.isArray(this.stride)||this.attribute.length!==this.stride.length)throw new Error("attribute or stride does not match");if(!0===Array.isArray(this.uniform)||!0===Array.isArray(this.type)){if(!0!==Array.isArray(this.uniform)||!0!==Array.isArray(this.type)||this.uniform.length!==this.type.length)throw new Error("uniform or type does not match")}else this.uniform=null,this.type=null;if(this.vertexShader=WebGLUtility.createShader(e,this.vertexShaderSource,e.VERTEX_SHADER),this.fragmentShader=WebGLUtility.createShader(e,this.fragmentShaderSource,e.FRAGMENT_SHADER),null==this.vertexShader||null==this.fragmentShader)throw new Error("shader compilation failed");if(!0===Array.isArray(this.transformFeedbackVaryings)&&this.transformFeedbackVaryings.length>0?this.program=WebGLUtility.createTransformFeedbackProgram(e,this.vertexShader,this.fragmentShader,this.transformFeedbackVaryings):this.program=WebGLUtility.createProgram(e,this.vertexShader,this.fragmentShader),null==this.program)throw new Error("shader program creation failed");this.attributeLocation=this.attribute.map(r=>{const t=e.getAttribLocation(this.program,r);return t<0&&console.warn(`"${r}" is an invalid attribute variable`),t}),null!=this.uniform&&(this.uniformLocation=this.uniform.map(r=>{const t=e.getUniformLocation(this.program,r);return null==t&&console.warn(`"${r}" is an invalid uniform variable`),t}))}use(){this.gl.useProgram(this.program)}setAttribute(e,r=null){const t=this.gl;if(!0!==Array.isArray(e)||e.length!==this.attribute.length)throw new Error("vbo or attribute does not match");e.forEach((e,r)=>{t.bindBuffer(t.ARRAY_BUFFER,e),t.enableVertexAttribArray(this.attributeLocation[r]),t.vertexAttribPointer(this.attributeLocation[r],this.stride[r],t.FLOAT,!1,0,0)}),null!=r&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,r)}setUniform(e){const r=this.gl;if(null!=this.uniform){if(!0!==Array.isArray(e)||e.length!==this.uniform.length)throw new Error("value is an invalid");e.forEach((e,t)=>{const a=this.type[t];!0===a.includes("Matrix")?r[a](this.uniformLocation[t],!1,e):r[a](this.uniformLocation[t],e)})}}}